<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>01 - Концепция компонента</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>
  <style type="text/css">body {background-color: green;}</style>
</head>
<body>
<h1 id="концепция-компонента">Концепция компонента</h1>
<p>Интерфейс строится из набора маленьких блоков - полей ввода, кнопок,
картинок и т.д. <em>Компонент</em> - это одна из основных концепций
реакта.</p>
<blockquote>
<p>Компонент может быть как совсем простым, например состоять из одной
кнопки, так и более сложным, например, объединять множество полей ввода,
кнопок в какую-нибудь анкету. Несколько компонентов могут
комбинироваться друг с другом и формировать еще более сложные компоненты
и т.д. Т.о. компонент - это переиспользуемый элемент пользовательского
интерфейса.</p>
</blockquote>
<h1 id="jsx">JSX</h1>
<p>Любой компонент возвращает JSX-разметку. JSX - это синтаксическое
расширение Javascript’а, которое содержит аналоги почти всех HTML-тегов
и позволяет удобным образом писать HTML-подобную разметку прямо в
компоненте, вместо того чтобы возиться с объектами. Потом реакт
преобразует эту разметку в настоящий HTML. По JSX есть отдельный
конспект.</p>
<h1 id="виды-компонентов">Виды компонентов</h1>
<h2 id="функциональный-компонент">Функциональный компонент</h2>
<p>Функциональный компонент - это функция, которая возвращает jsx.
Особенности и требования:</p>
<ul>
<li>Функция может быть как обычной, так и лямбдой. Обычно используются
лямбды или Function Declaration.</li>
<li>Название компонента (функции, переменной) нужно обязательно писать с
большой буквы, иначе работать не будет.</li>
<li>Нельзя вкладывать <em>объявления</em> компонентов друг в друга. В JS
мы можем объявлять одну функцию внутри другой, следовательно и компонент
можем описать внутри другого компонента. Делать так не надо. Каждый
компонент объявляется на верхнем уровне файла.</li>
<li>Вспомогательные функции следует размещать вне компонента, на верхнем
уровне, а требуемые данные передавать им в качестве параметров. Это
позволяет минимизировать код компонента, делая его более наглядным и
доступным для понимания.</li>
</ul>
<p>Примеры объявления функционального компонента:</p>
<pre class="react"><code>const Hello = () =&gt; {  // &lt;-- Лямбда
  return (
    &lt;h1&gt;Привет, мир!&lt;/h1&gt;
  );
};

export default Hello;</code></pre>
<pre class="react"><code>function Hello() {  // &lt;-- Function Declaration
  return (
    &lt;h1&gt;Привет, мир!&lt;/h1&gt;
  );
};

export default Hello;</code></pre>
<pre class="react"><code>const Hello = function() {  // &lt;-- Function Expression
  return (
    &lt;h1&gt;Привет, мир!&lt;/h1&gt;
  );
};

export default Hello;</code></pre>
<h2 id="классовый-компонент">Классовый компонент</h2>
<p>Описание компонентов через классы является устаревшим подходом и
рекомендуется пользоваться функциональными компонентами. Особенности
классовых компонентов:</p>
<ul>
<li>Класс должен наследоваться от класса
<code>React.Component</code>.</li>
<li>Конструктор должен принимать параметр props и передавать его в
родительский конструктор. Что такое пропсы - в отдельном конспекте.</li>
<li>Класс должен иметь метод <code>render()</code>, который возвращает
jsx.</li>
</ul>
<pre class="react"><code>import React from &#39;react&#39;;

class Hello extends React.Component {

  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;h1&gt;Привет, мир!&lt;/h1&gt;
    );
  }

}

export default Hello;</code></pre>
<h1 id="особенности-оформления-компонентов">Особенности оформления
компонентов</h1>
<p>Несколько хороших практик и технических замечаний о компонентах:</p>
<ul>
<li>Обычно придерживаются правила “один файл - один компонент” и
называют файл и компонент одинаково.
<ul>
<li>Расширение у файла может быть <code>.jsx</code>, <code>.js</code>
TODO: и наверняка какое-нибудь связанное с typescript.</li>
<li>Технически, в одном файле можно расположить несколько компонентов.
Подробнее о том, как это сделать и зачем, в конспекте про экспорт
 импорт компонентов.</li>
</ul></li>
<li>Возвращаемая из компонента JSX-разметка:
<ul>
<li>Должна быть завернута в единый блок, например
<code>&lt;div&gt;</code> или <code>&lt;Fragment&gt;</code>
(<code>&lt;&gt;</code>) и т.д. Это связано с тем, что каждый JSX-тег
трансформируется в обычный JS-объект, а значит вернуть несколько тегов,
не завернутых в единый тег, равносильно тому, что попробовать вернуть из
функции несколько независимых значений.</li>
<li>Для удобства можно брать разметку в круглые скобки
<code>return ( разметка )</code>. Это позволяет оформлять разметку на
нескольких строках и не бояться багов, связанных с автоматической
расстановкой js-ом точек с запятой.</li>
</ul></li>
<li>Компоненты всегда оформляются на верхнем уровне. Не надо оформлять
их в виде вложенных функций. Это приводит к багам (подробнее - в
конспекте по механикам изменения и сохранения состояния).</li>
</ul>
<h1 id="компоненты---чистые-функции">Компоненты - чистые функции</h1>
<p>Компоненты в реакт строятся по принципу чистой функции (pure
function).</p>
<p>Чистая функция это функция, которая:</p>
<ul>
<li>Выдает один и тот же результат, если получает одни и те же
аргументы. Т.е. выход зависит исключительно от входа.</li>
<li>Не имеет сайд-эффектов. Примеры сайд-эффектов: чтение  запись в БД,
отправка HTTP-запросов, работа с файловой системой. Т.е. каждый
очередной вызов функции не должен сопровождаться какими-то действиями,
которые могут привести к неочевидным последствиям. Чистая функция
принимает аргументы, обрабатывает их и после ее работы все “вокруг”
остается как было, как будто функцию вообще не вызывали. Благодаря этому
чистые функции можно вызывать повторно сколько угодно раз, не боясь, что
это повлияет на какие-то вещи, не касающиеся непосредственно
вычислений.</li>
</ul>
</body>
</html>
