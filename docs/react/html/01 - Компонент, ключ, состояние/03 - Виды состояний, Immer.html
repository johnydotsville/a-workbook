<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>03 - Виды состояний, Immer</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>
  <style type="text/css">body {background-color: green;}</style>
</head>
<body>
<h1 id="виды-состояний">Виды состояний</h1>
<h2 id="состояние-примитив">Состояние-примитив</h2>
<p>Было рассмотрено при объяснении хука useState.</p>
<h2 id="состояние-объект">Состояние-объект</h2>
<p>Когда состояние представлено объектом, мы придерживаемся правила
иммутабельности - сам объект не изменяем, а предоставляем сеттеру новый
объект:</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

const Counter = () =&gt; {
  const [data, setData] = useState({x: 5, y: 10});

  function increment() {
    setData({
      x: data.x + 1,
      y: data.y + 1
    });
  }

  function decrement() {
    setData({
      x: data.x - 1,
      y: data.y - 1
    });
  }

  return (
    &lt;div&gt;
      &lt;h1&gt;x: {data.x}, y: {data.y}&lt;/h1&gt;
      &lt;button onClick={increment}&gt;Увеличить&lt;/button&gt;
      &lt;button onClick={decrement}&gt;Уменьшить&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Counter;</code></pre>
<p>Когда объект большой, в нем много полей и если они к тому же вложены
друг в друга, то переписывать целиком такой объект не удобно. В этих
случаях нам поможет оператор разбиения <code>...</code> (см. конспект по
Javascript, если не понятно как он работает и как именно помогает в
данном случае):</p>
<pre class="react"><code>const [info, setInfo] = useState({  // &lt;-- Объект со множеством полей
  firstName: &#39;Alan&#39;,
  lastName: &#39;Wake&#39;,
  profession: &#39;writer&#39;
});

const changeReality = () =&gt; {
  setInfo({
    ...info,
    profession: &#39;crazy man with a gun&#39;
  });
}</code></pre>
<pre class="react"><code>const [info, setInfo] = useState({  // &lt;-- Объект со вложенными полями
  name: {
    firstName: &#39;Alan&#39;,
    lastName: &#39;Walker&#39;
  },
  profession: &#39;writer&#39;
});

const changeReality = () =&gt; {
  setInfo({
    ...info,
    name: {
      ...info.name,
      lastName: &#39;Wake&#39;
    }
  });
}</code></pre>
<p>В целом же стоит избегать глубоких вложений в состоянии и
проектировать его так, чтобы оно было как можно более плоским.</p>
<h2 id="состояние-массив">Состояние-массив</h2>
<p>Когда состояние является массивом, мы должны сохранять
иммутабельность: любая операция изменения состава массива (удаление,
добавление) выполняется через создание нового массива, копирования в
него элементов из старого, и установки нового массива в качестве
состояния.</p>
<h3 id="добавление-в-конец-начало-массива">Добавление в конец  начало
массива</h3>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: &#39;Мир&#39;},
    {id: 1, word: &#39;Труд&#39;},
    {id: 2, word: &#39;Май&#39;}
  ]);
  const [wordId, setWordId] = useState(words.length);
  const [word, setWord] = useState(&#39;&#39;);

  const handleAddNameClick = () =&gt; {
    setWords([...words, {id: wordId, word: word}]);  // &lt;-- Добавление в конец массива
    setWordId(wordId + 1);
  }

  return (
    &lt;div&gt;
      &lt;input onChange={e =&gt; setWord(e.target.value)} /&gt;
      &lt;button onClick={handleAddNameClick}&gt;Добавить&lt;/button&gt;
      &lt;ul&gt;
        {words.map(w =&gt; (&lt;li key={w.id}&gt;{w.word}&lt;/li&gt;))}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}</code></pre>
<p>Добавление <strong>в начало</strong> можно сделать так:
<code>setWords([{id: wordId, word: word}, ...words])</code></p>
<h3 id="удаление-из-массива">Удаление из массива</h3>
<p>Делается через фильтрацию методом <code>filter</code> массива:</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: &#39;Мир&#39;},
    {id: 1, word: &#39;Труд&#39;},
    {id: 2, word: &#39;Май&#39;}
  ]);
  const [wordId, setWordId] = useState(words.length);
  const [word, setWord] = useState(&#39;&#39;);

  const handleAddNameClick = () =&gt; {
    setWords([...words, {id: wordId, word: word}]);
    setWordId(wordId + 1);
  }

  const handleDeleteWordClick = (id) =&gt; {
    setWords(words.filter(w =&gt; w.id != id));  // &lt;-- Возвращаем новый массив без удаляемого элемента
  }

  return (
    &lt;div&gt;
      &lt;input onChange={e =&gt; setWord(e.target.value)} /&gt;
      &lt;button onClick={handleAddNameClick}&gt;Добавить&lt;/button&gt;
      &lt;ul&gt;
        {words.map(w =&gt; (
          &lt;li key={w.id}&gt;
            {w.word}
            &lt;button onClick={() =&gt; handleDeleteWordClick(w.id)}&gt;Удалить&lt;/button&gt;
          &lt;/li&gt;))
        }
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}</code></pre>
<h3 id="изменение-всех-элементов">Изменение всех элементов</h3>
<p>Делается методом <code>.map()</code> массива:</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: &#39;Мир&#39;},
    {id: 1, word: &#39;Труд&#39;},
    {id: 2, word: &#39;Май&#39;},
    {id: 3, word: &#39;Весна&#39;},
    {id: 4, word: &#39;Победа&#39;}
  ]);

  const handleTransformClick = () =&gt; {
    setWords(words.map((w, i) =&gt; i &gt; 1 ? {...w, word: w.word.toUpperCase()} : w));  // &lt;--
  }

  return (
    &lt;&gt;
      &lt;ul&gt;
        {words.map(w =&gt; &lt;li key={w.id}&gt;{w.word}&lt;/li&gt;)}
      &lt;/ul&gt;
      &lt;button onClick={handleTransformClick}&gt;Преобразовать&lt;/button&gt;
    &lt;/&gt;
  )
}</code></pre>
<h3 id="замена-конкретного-элемента">Замена конкретного элемента</h3>
<p>Тоже делается методом <code>.map()</code> массива. Просто пишем
условие так, чтобы заменился только один элемент:</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: &#39;Мир&#39;},
    {id: 1, word: &#39;Труд&#39;},
    {id: 2, word: &#39;Май&#39;},
    {id: 3, word: &#39;Весна&#39;},
    {id: 4, word: &#39;Победа&#39;}
  ]);
  const wordToSwap = &#39;Весна&#39;;
  const swapTo = &#39;Лето&#39;;

  const handleTransformClick = () =&gt; {
    setWords(words.map(w =&gt; !w.word.localeCompare(wordToSwap) ?  // &lt;--
      {...w, word: swapTo} : w));
  }

  return (
    &lt;&gt;
      &lt;ul&gt;
        {words.map(w =&gt; &lt;li key={w.id}&gt;{w.word}&lt;/li&gt;)}
      &lt;/ul&gt;
      &lt;button onClick={handleTransformClick}&gt;Преобразовать&lt;/button&gt;
    &lt;/&gt;
  )
}</code></pre>
<h3 id="вставка-элемента-в-середину-массива">Вставка элемента в середину
массива</h3>
<p>Делается комбинацией метода <code>.slice()</code> массива и оператора
разбиения. Методом slice возвращаем новый массив от начала до места
вставки, разбиваем полученный массив, потом ставим новый элемент, и
опять методом slice возвращаем новый массив от места вставки до конца,
разбиваем его и все это вместе заворачиваем в новый массив:</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: &#39;Мир&#39;},
    {id: 1, word: &#39;Труд&#39;},
    {id: 2, word: &#39;Май&#39;},
    {id: 3, word: &#39;Весна&#39;},
    {id: 4, word: &#39;Победа&#39;}
  ]);
  const [wordId, setWordId] = useState(words.length);
  const [word, setWord] = useState(&#39;&#39;);
  const middle = words.length / 2;  // &lt;-- Вставлять будем в середину массива

  const handleAddNameClick = () =&gt; {
    setWords([
      ...words.slice(0, middle),  // &lt;-- Выбираем подмассив до места вставки
      {id: wordId, word: word},   // &lt;-- Вставляем новый элемент
      ...words.slice(middle)      // &lt;-- Выбираем подмассив после места вставки
    ]);  // &lt;-- И из всех этих кусочков собираем новый массив
    setWordId(wordId + 1);
  }

  return (
    &lt;div&gt;
      &lt;input onChange={e =&gt; setWord(e.target.value)} /&gt;
      &lt;button onClick={handleAddNameClick}&gt;Добавить&lt;/button&gt;
      &lt;ul&gt;
        {words.map(w =&gt; (&lt;li key={w.id}&gt;{w.word}&lt;/li&gt;))}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}</code></pre>
<h3 id="сортировка-инверсия-массива">Сортировка, инверсия массива</h3>
<p>Методы <code>.sort()</code> и <code>.reverse()</code> мутируют
массив. Поэтому сначала делаем копию существующего массива, затем эту
копию сортируем  инвертируем и устанавливаем в качестве нового
состояния. Стоит помнить, что копия <em>поверхностная</em>, т.е. хоть
массив новый, но он содержит ссылки на исходные элементы, поэтому менять
их нельзя, т.к. иначе получится что мы изменим и исходное состояние.</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: &#39;Мир&#39;},
    {id: 1, word: &#39;Труд&#39;},
    {id: 2, word: &#39;Май&#39;},
    {id: 3, word: &#39;Весна&#39;},
    {id: 4, word: &#39;Победа&#39;}
  ]);

  const handleSortClick = () =&gt; {
    const copy = [...words];  // &lt;-- Делаем копию
    copy.sort((a, b) =&gt; a.word.localeCompare(b.word));  // &lt;-- Сортируем копию
    setWords(copy);  // &lt;-- Устанавливаем копию как новое состояние
  };
  const handleReverseClick = () =&gt; {
    const copy = [...words];  // &lt;-- Делаем копию
    copy.reverse();  // &lt;-- Инвертируем копию
    setWords(copy);  // &lt;-- Устанавливаем копию как новое состояние
  };

  return (
    &lt;div&gt;
      &lt;ul&gt;
        {words.map(w =&gt; (&lt;li key={w.id}&gt;{w.word}&lt;/li&gt;))}
      &lt;/ul&gt;
      &lt;button onClick={handleSortClick}&gt;Сортировать&lt;/button&gt;
      &lt;button onClick={handleReverseClick}&gt;Инвертировать&lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre>
<p>В примере разбито на три строчки для наглядности, а кратко делаем
так:
<code>setWords([...words].sort((a, b) =&gt; a.word.localeCompare(b.word)));</code></p>
<h2 id="библиотека-immer">Библиотека Immer</h2>
<p>Чтобы сделать работу с иммутабельным состоянием удобнее и нагляднее,
существует библиотека <code>Immer</code>. Если я о ней и напишу, то это
будет отдельный конспект.</p>
</body>
</html>
