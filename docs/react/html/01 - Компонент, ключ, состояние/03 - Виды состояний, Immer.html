<!DOCTYPE html>
<html>
<head>
    <title></title>
    <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css'>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js'></script>
    <script>hljs.highlightAll();</script>
    <style>* {
  box-sizing: border-box;
}


html {
  scroll-behavior: smooth;

  text-align: justify;       /* Выравнивание по ширине */
  text-align-last: left;     /* Последняя строка - по левому краю */
  hyphens: auto;             /* Перенос слов (опционально) */
}


body {
  margin: 0;
  padding: 0;
  background-color: #1E1E1E;
}


h1 {
  font-size: 2.5rem;
}


.content {
  max-width: 800px;
  padding: 20px;
  margin: 0 auto;
  background-color: #FFC6A3;
}</style>
</head>
<body>
  <section class="content">
    <h1 id="виды-состояний">Виды состояний</h1>
    <h2 id="состояние-примитив">Состояние-примитив</h2>
    <p>Было рассмотрено при объяснении хука useState.</p>
    <h2 id="состояние-объект">Состояние-объект</h2>
    <p>Когда состояние представлено объектом, мы придерживаемся правила
    иммутабельности - сам объект не изменяем, а предоставляем сеттеру
    новый объект:</p>
    <pre class="react"><code>import {useState} from &#39;react&#39;;

const Counter = () =&gt; {
  const [data, setData] = useState({x: 5, y: 10});

  function increment() {
    setData({
      x: data.x + 1,
      y: data.y + 1
    });
  }

  function decrement() {
    setData({
      x: data.x - 1,
      y: data.y - 1
    });
  }

  return (
    &lt;div&gt;
      &lt;h1&gt;x: {data.x}, y: {data.y}&lt;/h1&gt;
      &lt;button onClick={increment}&gt;Увеличить&lt;/button&gt;
      &lt;button onClick={decrement}&gt;Уменьшить&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Counter;</code></pre>
    <p>Когда объект большой, в нем много полей и если они к тому же
    вложены друг в друга, то переписывать целиком такой объект не
    удобно. В этих случаях нам поможет оператор разбиения
    <code>...</code> (см. конспект по Javascript, если не понятно как он
    работает и как именно помогает в данном случае):</p>
    <pre class="react"><code>const [info, setInfo] = useState({  // &lt;-- Объект со множеством полей
  firstName: &#39;Alan&#39;,
  lastName: &#39;Wake&#39;,
  profession: &#39;writer&#39;
});

const changeReality = () =&gt; {
  setInfo({
    ...info,
    profession: &#39;crazy man with a gun&#39;
  });
}</code></pre>
    <pre class="react"><code>const [info, setInfo] = useState({  // &lt;-- Объект со вложенными полями
  name: {
    firstName: &#39;Alan&#39;,
    lastName: &#39;Walker&#39;
  },
  profession: &#39;writer&#39;
});

const changeReality = () =&gt; {
  setInfo({
    ...info,
    name: {
      ...info.name,
      lastName: &#39;Wake&#39;
    }
  });
}</code></pre>
    <p>В целом же стоит избегать глубоких вложений в состоянии и
    проектировать его так, чтобы оно было как можно более плоским.</p>
    <h2 id="состояние-массив">Состояние-массив</h2>
    <p>Когда состояние является массивом, мы должны сохранять
    иммутабельность: любая операция изменения состава массива (удаление,
    добавление) выполняется через создание нового массива, копирования в
    него элементов из старого, и установки нового массива в качестве
    состояния.</p>
    <h3 id="добавление-в-конец-начало-массива">Добавление в конец
     начало массива</h3>
    <pre class="react"><code>import {useState} from &#39;react&#39;;

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: &#39;Мир&#39;},
    {id: 1, word: &#39;Труд&#39;},
    {id: 2, word: &#39;Май&#39;}
  ]);
  const [wordId, setWordId] = useState(words.length);
  const [word, setWord] = useState(&#39;&#39;);

  const handleAddNameClick = () =&gt; {
    setWords([...words, {id: wordId, word: word}]);  // &lt;-- Добавление в конец массива
    setWordId(wordId + 1);
  }

  return (
    &lt;div&gt;
      &lt;input onChange={e =&gt; setWord(e.target.value)} /&gt;
      &lt;button onClick={handleAddNameClick}&gt;Добавить&lt;/button&gt;
      &lt;ul&gt;
        {words.map(w =&gt; (&lt;li key={w.id}&gt;{w.word}&lt;/li&gt;))}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}</code></pre>
    <p>Добавление <strong>в начало</strong> можно сделать так:
    <code>setWords([{id: wordId, word: word}, ...words])</code></p>
    <h3 id="удаление-из-массива">Удаление из массива</h3>
    <p>Делается через фильтрацию методом <code>filter</code>
    массива:</p>
    <pre class="react"><code>import {useState} from &#39;react&#39;;

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: &#39;Мир&#39;},
    {id: 1, word: &#39;Труд&#39;},
    {id: 2, word: &#39;Май&#39;}
  ]);
  const [wordId, setWordId] = useState(words.length);
  const [word, setWord] = useState(&#39;&#39;);

  const handleAddNameClick = () =&gt; {
    setWords([...words, {id: wordId, word: word}]);
    setWordId(wordId + 1);
  }

  const handleDeleteWordClick = (id) =&gt; {
    setWords(words.filter(w =&gt; w.id != id));  // &lt;-- Возвращаем новый массив без удаляемого элемента
  }

  return (
    &lt;div&gt;
      &lt;input onChange={e =&gt; setWord(e.target.value)} /&gt;
      &lt;button onClick={handleAddNameClick}&gt;Добавить&lt;/button&gt;
      &lt;ul&gt;
        {words.map(w =&gt; (
          &lt;li key={w.id}&gt;
            {w.word}
            &lt;button onClick={() =&gt; handleDeleteWordClick(w.id)}&gt;Удалить&lt;/button&gt;
          &lt;/li&gt;))
        }
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}</code></pre>
    <h3 id="изменение-всех-элементов">Изменение всех элементов</h3>
    <p>Делается методом <code>.map()</code> массива:</p>
    <pre class="react"><code>import {useState} from &#39;react&#39;;

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: &#39;Мир&#39;},
    {id: 1, word: &#39;Труд&#39;},
    {id: 2, word: &#39;Май&#39;},
    {id: 3, word: &#39;Весна&#39;},
    {id: 4, word: &#39;Победа&#39;}
  ]);

  const handleTransformClick = () =&gt; {
    setWords(words.map((w, i) =&gt; i &gt; 1 ? {...w, word: w.word.toUpperCase()} : w));  // &lt;--
  }

  return (
    &lt;&gt;
      &lt;ul&gt;
        {words.map(w =&gt; &lt;li key={w.id}&gt;{w.word}&lt;/li&gt;)}
      &lt;/ul&gt;
      &lt;button onClick={handleTransformClick}&gt;Преобразовать&lt;/button&gt;
    &lt;/&gt;
  )
}</code></pre>
    <h3 id="замена-конкретного-элемента">Замена конкретного
    элемента</h3>
    <p>Тоже делается методом <code>.map()</code> массива. Просто пишем
    условие так, чтобы заменился только один элемент:</p>
    <pre class="react"><code>import {useState} from &#39;react&#39;;

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: &#39;Мир&#39;},
    {id: 1, word: &#39;Труд&#39;},
    {id: 2, word: &#39;Май&#39;},
    {id: 3, word: &#39;Весна&#39;},
    {id: 4, word: &#39;Победа&#39;}
  ]);
  const wordToSwap = &#39;Весна&#39;;
  const swapTo = &#39;Лето&#39;;

  const handleTransformClick = () =&gt; {
    setWords(words.map(w =&gt; !w.word.localeCompare(wordToSwap) ?  // &lt;--
      {...w, word: swapTo} : w));
  }

  return (
    &lt;&gt;
      &lt;ul&gt;
        {words.map(w =&gt; &lt;li key={w.id}&gt;{w.word}&lt;/li&gt;)}
      &lt;/ul&gt;
      &lt;button onClick={handleTransformClick}&gt;Преобразовать&lt;/button&gt;
    &lt;/&gt;
  )
}</code></pre>
    <h3 id="вставка-элемента-в-середину-массива">Вставка элемента в
    середину массива</h3>
    <p>Делается комбинацией метода <code>.slice()</code> массива и
    оператора разбиения. Методом slice возвращаем новый массив от начала
    до места вставки, разбиваем полученный массив, потом ставим новый
    элемент, и опять методом slice возвращаем новый массив от места
    вставки до конца, разбиваем его и все это вместе заворачиваем в
    новый массив:</p>
    <pre class="react"><code>import {useState} from &#39;react&#39;;

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: &#39;Мир&#39;},
    {id: 1, word: &#39;Труд&#39;},
    {id: 2, word: &#39;Май&#39;},
    {id: 3, word: &#39;Весна&#39;},
    {id: 4, word: &#39;Победа&#39;}
  ]);
  const [wordId, setWordId] = useState(words.length);
  const [word, setWord] = useState(&#39;&#39;);
  const middle = words.length / 2;  // &lt;-- Вставлять будем в середину массива

  const handleAddNameClick = () =&gt; {
    setWords([
      ...words.slice(0, middle),  // &lt;-- Выбираем подмассив до места вставки
      {id: wordId, word: word},   // &lt;-- Вставляем новый элемент
      ...words.slice(middle)      // &lt;-- Выбираем подмассив после места вставки
    ]);  // &lt;-- И из всех этих кусочков собираем новый массив
    setWordId(wordId + 1);
  }

  return (
    &lt;div&gt;
      &lt;input onChange={e =&gt; setWord(e.target.value)} /&gt;
      &lt;button onClick={handleAddNameClick}&gt;Добавить&lt;/button&gt;
      &lt;ul&gt;
        {words.map(w =&gt; (&lt;li key={w.id}&gt;{w.word}&lt;/li&gt;))}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}</code></pre>
    <h3 id="сортировка-инверсия-массива">Сортировка, инверсия
    массива</h3>
    <p>Методы <code>.sort()</code> и <code>.reverse()</code> мутируют
    массив. Поэтому сначала делаем копию существующего массива, затем
    эту копию сортируем  инвертируем и устанавливаем в качестве нового
    состояния. Стоит помнить, что копия <em>поверхностная</em>, т.е.
    хоть массив новый, но он содержит ссылки на исходные элементы,
    поэтому менять их нельзя, т.к. иначе получится что мы изменим и
    исходное состояние.</p>
    <pre class="react"><code>import {useState} from &#39;react&#39;;

export default function Words() {
  const [words, setWords] = useState([
    {id: 0, word: &#39;Мир&#39;},
    {id: 1, word: &#39;Труд&#39;},
    {id: 2, word: &#39;Май&#39;},
    {id: 3, word: &#39;Весна&#39;},
    {id: 4, word: &#39;Победа&#39;}
  ]);

  const handleSortClick = () =&gt; {
    const copy = [...words];  // &lt;-- Делаем копию
    copy.sort((a, b) =&gt; a.word.localeCompare(b.word));  // &lt;-- Сортируем копию
    setWords(copy);  // &lt;-- Устанавливаем копию как новое состояние
  };
  const handleReverseClick = () =&gt; {
    const copy = [...words];  // &lt;-- Делаем копию
    copy.reverse();  // &lt;-- Инвертируем копию
    setWords(copy);  // &lt;-- Устанавливаем копию как новое состояние
  };

  return (
    &lt;div&gt;
      &lt;ul&gt;
        {words.map(w =&gt; (&lt;li key={w.id}&gt;{w.word}&lt;/li&gt;))}
      &lt;/ul&gt;
      &lt;button onClick={handleSortClick}&gt;Сортировать&lt;/button&gt;
      &lt;button onClick={handleReverseClick}&gt;Инвертировать&lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre>
    <p>В примере разбито на три строчки для наглядности, а кратко делаем
    так:
    <code>setWords([...words].sort((a, b) =&gt; a.word.localeCompare(b.word)));</code></p>
    <h2 id="библиотека-immer">Библиотека Immer</h2>
    <p>Чтобы сделать работу с иммутабельным состоянием удобнее и
    нагляднее, существует библиотека <code>Immer</code>. Если я о ней и
    напишу, то это будет отдельный конспект.</p>
  </section>
</body>
</html>
