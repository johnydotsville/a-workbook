<!DOCTYPE html>
<html>
<head>
    <title></title>
    <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css'>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js'></script>
    <script>hljs.highlightAll();</script>
    <style>* {
  box-sizing: border-box;
}


html {
  scroll-behavior: smooth;

  text-align: justify;       /* Выравнивание по ширине */
  text-align-last: left;     /* Последняя строка - по левому краю */
  hyphens: auto;             /* Перенос слов (опционально) */
}


body {
  margin: 0;
  padding: 0;
  background-color: #1E1E1E;
}


h1 {
  font-size: 2.5rem;
}


.content {
  max-width: 800px;
  padding: 20px;
  margin: 0 auto;
  background-color: #FFC6A3;
}</style>
</head>
<body>
  <section class="content">
    <h1 id="состояние-компонента">Состояние компонента</h1>
    <h2 id="функциональный-компонент">Функциональный компонент</h2>
    <h3 id="хук-usestate">Хук useState</h3>
    <pre class="react"><code>import {useState} from &#39;react&#39;;</code></pre>
    <p>Состояние компонента - это некоторые данные, которые компонент
    использует. Например, состоянием компонента “Анкета” может быть имя
    человека, профессия, дата рождения.</p>
    <p>Работа с состоянием компонента начинается с вызова функции-хука
    <code>useState(начальное_состояние)</code>. Мы передаем в нее
    значение  объект, который хотим использовать в качестве начального
    состояния, а она нам возвращает переменную, содержащую это
    состояние, плюс функцию для его изменения.</p>
    <pre class="react"><code>const [состояние, функцияДляИзмененияСостояния] = useState(5);
const [login, setLogin] = useState(&#39;neofit&#39;);</code></pre>
    <p>Теперь, чтобы изменить состояние компонента, мы вызываем
    полученную от хука функцию, передавая в нее новое значение
    состояния. Вручную переменную состояния мы не изменяем, потому что в
    этом нет смысла, ибо реакт эти изменения не увидит, а используем ее
    для чтения состояния и формирования нового состояния на основе
    текущего. Т.о., состояние мы всегда воспринимаем как иммутабельное
    значение, которое можно <strong>за</strong>менить, но не
    <strong>из</strong>менить. Имя для функции изменения состояния может
    быть произвольным, но лучше при именовании следовать соглашению
    <code>переменнаяСостояния</code>,
    <code>setПеременнаяСостояния</code>.</p>
    <p>У компонента может быть много состояний, т.е. мы можем применять
    хук useState сколько угодно раз. Состояние не стоит воспринимать как
    монолитный объект, содержащий все-все-все данные, касающиеся
    компонента. Наоборот, данные компонента могут быть разбиты на
    небольшие кусочки, несколько “состояний”, каждое из которых может
    меняться независимо.</p>
    <pre class="react"><code>import {useState} from &#39;react&#39;;

const Counter = () =&gt; {
  const [count, setCount] = useState(5);  // &lt;-- Создали состояние и получили ф-ию для его измения
  const [calls, setCalls] = useState(0);  // &lt;-- Другое состояние, под общее число кликов по счетчику

  function increment() {
    setCount(count + 1);  // &lt;-- Сообщаем реакту об изменении состояния
    // Но саму переменную count мы не меняем
    setCalls(calls + 1);
  }

  function decrement() {
    setCount(count - 1);
    setCalls(calls + 1);
  }

  return (
    &lt;div&gt;
      &lt;h1&gt;{count}&lt;/h1&gt;
      &lt;h2&gt;Общее число обращений к счетчику: {calls}&lt;/h2&gt;
      &lt;button onClick={increment}&gt;Увеличить&lt;/button&gt;
      &lt;button onClick={decrement}&gt;Уменьшить&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Counter;</code></pre>
    <h2 id="классовый-компонент">Классовый компонент</h2>
    <ul>
    <li>В классовом компоненте состояние объявляется в
    конструкторе.</li>
    <li>Под состояние существует свойство <code>state</code>.
    <ul>
    <li>Для изменения состояния - метод <code>setState</code>.</li>
    </ul></li>
    <li>Все методы класса необходимо биндить, потому что теряется
    контекст. TODO: можно кстати почитать, почему так происходит.</li>
    </ul>
    <pre class="react"><code>import React from &#39;react&#39;;

class Counter extends React.Component {
  
  constructor(props) {
    super(props);
    this.state = {  // &lt;-- Объявление состояния
      count: 5
    };
    this.increment = this.increment.bind(this);  // &lt;-- Надо биндить методы
    this.decrement = this.decrement.bind(this);  // &lt;-- Надо биндить методы
  }

  increment() {
    this.setState({
      count: this.state.count + 1
    });
  }

  decrement() {
    this.setState({
      count: this.state.count - 1
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;{this.state.count}&lt;/h1&gt;
        &lt;button onClick={this.increment}&gt;Увеличить&lt;/button&gt;
        &lt;button onClick={this.decrement}&gt;Уменьшить&lt;/button&gt;
      &lt;/div&gt;
    );
  }

}

export default Counter;</code></pre>
    <h1 id="советы-по-оформлению-состояния">Советы по оформлению
    состояния</h1>
    <p>Несколько советов по оформлению состояния:</p>
    <ul>
    <li>Группируйте связанные состояния. Если вы обнаружили, что обычно
    изменяете две и более переменные состояния вместе и они логически
    тесто связаны, то лучше их объединить в единый объект.</li>
    <li>Избегайте противоречий в состоянии. Если у вас несколько
    состояний, значения которых могут конфликтовать, то эти состояния
    нужно отрефакторить, чтобы такого конфликта в принципе не могло
    произойти. Например, комбинация <code>isSending = true</code> и
    <code>isSent = true</code> является некорректной с точки зрения
    логики программы, потому что сообщение не может одновременно
    отправлять и быть уже отправленным. Пример рефакторинга - ввести
    состояние <code>status</code> с возможными значениями sending и
    sent.</li>
    <li>Избегайте избыточности в состоянии. Если какие-то значения можно
    вычислить на основе имеющихся средств (например пропсы или другие
    состояния), то не нужно для этих значений заводить отдельное
    состояние. Пример избыточного состояния: <code>firstname</code>,
    <code>lastname</code>, <code>fullname</code>. Здесь fullname можно
    вычислить на основе firstname и lastname, поэтому держать его как
    отдельное состояние не следует.</li>
    <li>Избегайте дублирования в состоянии. Не стоит использовать одни и
    те же данные как части разных состояний, потому что их придется
    держать их в согласованном виде, а это повышает вероятность ошибок.
    Например: список элементов и состояние <code>selectedItem</code>.
    Если сохранить в selectedItem непосредственно ссылку на элемент, то
    это плохая идея. Из-за иммутабельности, в случае изменений в
    выделенном элементе, нам придется заменять элемент и в selectedItem.
    Проще и правильнее будет сохранить в selectedItem id выбранного
    элемента.</li>
    <li>Избегайте сильной вложенности в состоянии. Старайтесь делать
    состояние как можно более плоским, потому что так его будет проще
    обновлять.</li>
    </ul>
  </section>
</body>
</html>
