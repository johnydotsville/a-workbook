<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>02 - Состояние компонента, хук useState</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>
  <style type="text/css">body {background-color: green;}</style>
</head>
<body>
<h1 id="состояние-компонента">Состояние компонента</h1>
<h2 id="функциональный-компонент">Функциональный компонент</h2>
<h3 id="хук-usestate">Хук useState</h3>
<pre class="react"><code>import {useState} from &#39;react&#39;;</code></pre>
<p>Состояние компонента - это некоторые данные, которые компонент
использует. Например, состоянием компонента “Анкета” может быть имя
человека, профессия, дата рождения.</p>
<p>Работа с состоянием компонента начинается с вызова функции-хука
<code>useState(начальное_состояние)</code>. Мы передаем в нее значение
 объект, который хотим использовать в качестве начального состояния, а
она нам возвращает переменную, содержащую это состояние, плюс функцию
для его изменения.</p>
<pre class="react"><code>const [состояние, функцияДляИзмененияСостояния] = useState(5);
const [login, setLogin] = useState(&#39;neofit&#39;);</code></pre>
<p>Теперь, чтобы изменить состояние компонента, мы вызываем полученную
от хука функцию, передавая в нее новое значение состояния. Вручную
переменную состояния мы не изменяем, потому что в этом нет смысла, ибо
реакт эти изменения не увидит, а используем ее для чтения состояния и
формирования нового состояния на основе текущего. Т.о., состояние мы
всегда воспринимаем как иммутабельное значение, которое можно
<strong>за</strong>менить, но не <strong>из</strong>менить. Имя для
функции изменения состояния может быть произвольным, но лучше при
именовании следовать соглашению <code>переменнаяСостояния</code>,
<code>setПеременнаяСостояния</code>.</p>
<p>У компонента может быть много состояний, т.е. мы можем применять хук
useState сколько угодно раз. Состояние не стоит воспринимать как
монолитный объект, содержащий все-все-все данные, касающиеся компонента.
Наоборот, данные компонента могут быть разбиты на небольшие кусочки,
несколько “состояний”, каждое из которых может меняться независимо.</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

const Counter = () =&gt; {
  const [count, setCount] = useState(5);  // &lt;-- Создали состояние и получили ф-ию для его измения
  const [calls, setCalls] = useState(0);  // &lt;-- Другое состояние, под общее число кликов по счетчику

  function increment() {
    setCount(count + 1);  // &lt;-- Сообщаем реакту об изменении состояния
    // Но саму переменную count мы не меняем
    setCalls(calls + 1);
  }

  function decrement() {
    setCount(count - 1);
    setCalls(calls + 1);
  }

  return (
    &lt;div&gt;
      &lt;h1&gt;{count}&lt;/h1&gt;
      &lt;h2&gt;Общее число обращений к счетчику: {calls}&lt;/h2&gt;
      &lt;button onClick={increment}&gt;Увеличить&lt;/button&gt;
      &lt;button onClick={decrement}&gt;Уменьшить&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Counter;</code></pre>
<h2 id="классовый-компонент">Классовый компонент</h2>
<ul>
<li>В классовом компоненте состояние объявляется в конструкторе.</li>
<li>Под состояние существует свойство <code>state</code>.
<ul>
<li>Для изменения состояния - метод <code>setState</code>.</li>
</ul></li>
<li>Все методы класса необходимо биндить, потому что теряется контекст.
TODO: можно кстати почитать, почему так происходит.</li>
</ul>
<pre class="react"><code>import React from &#39;react&#39;;

class Counter extends React.Component {
  
  constructor(props) {
    super(props);
    this.state = {  // &lt;-- Объявление состояния
      count: 5
    };
    this.increment = this.increment.bind(this);  // &lt;-- Надо биндить методы
    this.decrement = this.decrement.bind(this);  // &lt;-- Надо биндить методы
  }

  increment() {
    this.setState({
      count: this.state.count + 1
    });
  }

  decrement() {
    this.setState({
      count: this.state.count - 1
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;{this.state.count}&lt;/h1&gt;
        &lt;button onClick={this.increment}&gt;Увеличить&lt;/button&gt;
        &lt;button onClick={this.decrement}&gt;Уменьшить&lt;/button&gt;
      &lt;/div&gt;
    );
  }

}

export default Counter;</code></pre>
<h1 id="советы-по-оформлению-состояния">Советы по оформлению
состояния</h1>
<p>Несколько советов по оформлению состояния:</p>
<ul>
<li>Группируйте связанные состояния. Если вы обнаружили, что обычно
изменяете две и более переменные состояния вместе и они логически тесто
связаны, то лучше их объединить в единый объект.</li>
<li>Избегайте противоречий в состоянии. Если у вас несколько состояний,
значения которых могут конфликтовать, то эти состояния нужно
отрефакторить, чтобы такого конфликта в принципе не могло произойти.
Например, комбинация <code>isSending = true</code> и
<code>isSent = true</code> является некорректной с точки зрения логики
программы, потому что сообщение не может одновременно отправлять и быть
уже отправленным. Пример рефакторинга - ввести состояние
<code>status</code> с возможными значениями sending и sent.</li>
<li>Избегайте избыточности в состоянии. Если какие-то значения можно
вычислить на основе имеющихся средств (например пропсы или другие
состояния), то не нужно для этих значений заводить отдельное состояние.
Пример избыточного состояния: <code>firstname</code>,
<code>lastname</code>, <code>fullname</code>. Здесь fullname можно
вычислить на основе firstname и lastname, поэтому держать его как
отдельное состояние не следует.</li>
<li>Избегайте дублирования в состоянии. Не стоит использовать одни и те
же данные как части разных состояний, потому что их придется держать их
в согласованном виде, а это повышает вероятность ошибок. Например:
список элементов и состояние <code>selectedItem</code>. Если сохранить в
selectedItem непосредственно ссылку на элемент, то это плохая идея.
Из-за иммутабельности, в случае изменений в выделенном элементе, нам
придется заменять элемент и в selectedItem. Проще и правильнее будет
сохранить в selectedItem id выбранного элемента.</li>
<li>Избегайте сильной вложенности в состоянии. Старайтесь делать
состояние как можно более плоским, потому что так его будет проще
обновлять.</li>
</ul>
</body>
</html>
