<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>05 - Механики изменения и сохранения состояния</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>
  <style type="text/css">body {background-color: green;}</style>
</head>
<body>
<h1 id="механика-изменения-состояния">Механика изменения состояния</h1>
<h2 id="очередь-изменений">Очередь изменений</h2>
<p>Обычные локальные переменные не могут формировать состояние, потому
что между рендерингами они не сохраняются. Все потому, что компонент -
это обычная функция, которая возвращает JSX, а каждый рендер - это новый
вызов функции. Стало быть, все локальные переменные от прошлого вызова
давно стерты из памяти. Состояние же не является локальной переменной
компонента, можно сказать, что оно хранится “в самом реакте”.</p>
<p>Изменение состояния вызывает повторный рендеринг компонента. Однако
он происходит не мгновенно. Наглядный пример:</p>
<pre class="react"><code>import { useState } from &#39;react&#39;;

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    &lt;&gt;
      &lt;h1&gt;{number}&lt;/h1&gt;
      &lt;button onClick={() =&gt; {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}&gt;+3&lt;/button&gt;
    &lt;/&gt;
  )
}</code></pre>
<p>При щелчке по кнопке счетчик увеличится на 1, а не на 3. Это
происходит по нескольким причинам:</p>
<ul>
<li>Вызов сеттера не приводит к <em>моментальному</em> изменению
состояния. Этот вызов можно воспринимать как заказ на изменение
состояния при <em>следующем рендеринге</em>. Код обработчика onClick
сначала выполнится полностью, прежде чем что-то изменится. Сделано это
для того, чтобы не вызывать рендеринг слишком часто. Например, будь у
нас несколько состояний, то в этом обработчике мы могли бы вызывать
несколько сеттеров разных состояний. В таком случае было бы выгоднее
сначала окончательно определиться со всеми значениями, а потом разом их
отрисовать. Плюс это исключает проблему, что состояние могло бы быть
отрисовано как-то частично.</li>
<li>Раз вызов сеттера не приводит к моментальному изменению состояния,
получается что в пределах одного рендера состояние всегда одинаковое.
Так что каждая из строк <code>setNumber(number + 1)</code> по сути
выглядит как <code>setNumber(0 + 1)</code>.</li>
</ul>
<h2 id="функция-апдейтер">Функция-апдейтер</h2>
<p>Когда мы передаем в сеттер только значение, то сеттер работает по
принципу замены текущего состояния на новое значение. Если же мы
передадим в него функцию с единственным параметром, то сеттер нам через
этот параметр передаст текущее значение состояния. Т.о. мы сможем
переписать предыдущий пример, чтобы счетчик увеличивался на 3:</p>
<pre class="react"><code>import { useState } from &#39;react&#39;;

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    &lt;&gt;
      &lt;h1&gt;{number}&lt;/h1&gt;
      &lt;button onClick={() =&gt; {
        setNumber(n =&gt; n + 1);  {/* Почувствуй разницу с number + 1 */}
        setNumber(n =&gt; n + 1);
        setNumber(n =&gt; n + 1);
      }}&gt;+3&lt;/button&gt;
    &lt;/&gt;
  )
}</code></pre>
<p>Данный пример будет работать фактически так:</p>
<pre><code>0 =&gt; 0 + 1;  // n = 1
1 =&gt; 1 + 1;  // n = 2
2 =&gt; 2 + 1;  // n = 3</code></pre>
<p>Пара дополнительных примеров для тренировки, чему будет равно
итоговое состояние в каждом случае (исходное значение 0)?</p>
<pre class="react"><code>&lt;button onClick={() =&gt; {
  setNumber(number + 5);
  setNumber(n =&gt; n + 1);
}}&gt;
    
&lt;button onClick={() =&gt; {
  setNumber(number + 5);
  setNumber(n =&gt; n + 1);
  setNumber(42);
}}&gt;</code></pre>
<p>Ответы: шесть и сорок два.</p>
<h2 id="момент-инициализации-состояния">Момент инициализации
состояния</h2>
<p>Состояние инициализируется только единожды - при самом первом
рендере. Это важно помнить на случай, когда состояние инициализируется
на основе пропсов, потому что в случае если родитель передаст потом
новое значение, то состояние дочернего компонента не поменяется. Поэтому
вот такие конструкции <em>обычно</em> не рекомендуется использовать
(называется <em>mirroring</em>):</p>
<pre class="react"><code>function Message({ messageColor }) {
  const [color, setColor] = useState(messageColor);</code></pre>
<p>Вместо этого следует использовать значение пропса напрямую.</p>
<p>Однако если мироринг используется намеренно, т.е. так и нужно, чтобы
состояние инициализировалось переданным значением единожды, то для
явного отражения этого намерения принято использовать префикс
<code>initial</code> или <code>default</code> для пропса:</p>
<pre class="react"><code>function Message({ initialColor }) {
  // Переменная состояния color сохранит первое значение пропса initialColor.
  // Последующие изменения пропса initialColor не повлияют на состояние.
  const [color, setColor] = useState(initialColor);</code></pre>
<h1 id="механика-сохранения-состояния">Механика сохранения
состояния</h1>
<p>Состояние не хранится внутри компонента, оно хранится “внутри реакта”
и он сопоставляет состояние с конкретным компонентом на основе позиции
компонента в UI-дереве (меется ввиду не HTML-дерево, которое в итоге
получается в браузере, а именно реактовское дерево, на основе которого
потом рисуется HTML). На практике это означает следующие вещи:</p>
<h2 id="вещь-1">Вещь #1</h2>
<blockquote>
<p>Если компонент убирается из дерева, то реакт удаляет связанное с ним
состояние.</p>
</blockquote>
<p>Пример: если нащелкать счетчик B, а потом скрыть-показать его, то
увидим, что состояние сбросилось:</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function StatePreserveDemo() {
  const [showB, setShowB] = useState(true);
  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;Counter title=&quot;A&quot; /&gt;
        {showB &amp;&amp; &lt;Counter title=&quot;B&quot; /&gt;}
      &lt;/div&gt;
      &lt;button onClick={() =&gt; setShowB(!showB)}&gt;{showB ? &#39;Скрыть&#39; : &#39;Показать&#39;} B&lt;/button&gt;
    &lt;/&gt;
  )
}

function Counter({title}) {
  const [count, setCount] = useState(0);
  return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{title}: {count}&lt;/button&gt;
}</code></pre>
<h2 id="вещь-2">Вещь #2</h2>
<blockquote>
<p>Если компонент сохраняет ту же позицию в дереве, то его состояние
сохраняется. Если компонент меняет позицию, то он уже считается за
другой компонент и соответственно его состояние тоже новое.</p>
</blockquote>
<p>Пример: можно нащелкать счетчик, потом переименовать его и состояние
сохранится. Все потому, что компонент сохраняет свою исходную позицию в
дереве - в <code>&lt;div&gt;</code> и на первом месте.</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function StatePreserveDemo() {
  const [rename, setRename] = useState(true);
  return (
    &lt;&gt;
      {
        rename ? (
          &lt;div&gt;&lt;Counter title=&#39;Щелкунчик&#39; /&gt;&lt;/div&gt;
        ) : (
          &lt;div&gt;&lt;Counter title=&#39;Counter&#39; /&gt;&lt;/div&gt;
        )
      }
      &lt;button onClick={() =&gt; setRename(!rename)}&gt;Переименовать&lt;/button&gt;
    &lt;/&gt;
  )
}

function Counter({title}) {
  const [count, setCount] = useState(0);
  return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{title}: {count}&lt;/button&gt;
}</code></pre>
<p>Пример: нащелкиваем счетчик, а после переименования видим, что он
сбросился. Все потому, что при переименовании изменяется позиция
компонента - хотя он все еще на первом месте, но был завернут в
<code>&lt;div&gt;</code>, а стал в <code>&lt;section&gt;</code> и
наоборот. Поэтому для реакта это разные компоненты и состояние старого
сбрасывается. Также сбросятся и состояния всех его дочерних
компонентов:</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function StatePreserveDemo() {
  const [rename, setRename] = useState(true);
  return (
    &lt;&gt;
      {
        rename ? (
          &lt;div&gt;&lt;Counter title=&#39;Щелкунчик&#39; /&gt;&lt;/div&gt;
        ) : (
          &lt;section&gt;&lt;Counter title=&#39;Counter&#39; /&gt;&lt;/section&gt;
        )
      }
      &lt;button onClick={() =&gt; setRename(!rename)}&gt;Переименовать&lt;/button&gt;
    &lt;/&gt;
  )
}

function Counter({title}) {
  const [count, setCount] = useState(0);
  return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{title}: {count}&lt;/button&gt;
}</code></pre>
<p>Пример 3: каждый блок в фигурных скобках является самостоятельным
узлом реакт-дерева, который в итоге рендерится или не рендерится в
конечный HTML. В предыдущих примерах был один блок, внутри которого
условие, и результатом блока являлась та или иная разметка. А вот
пример, где два блока:</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function StatePreserveDemo() {
  const [rename, setRename] = useState(true);
  return (
    &lt;&gt;
      { rename &amp;&amp; &lt;div&gt;&lt;Counter title=&#39;Щелкунчик&#39; /&gt;&lt;/div&gt; }
      { !rename &amp;&amp; &lt;div&gt;&lt;Counter title=&#39;Counter&#39; /&gt;&lt;/div&gt; }
      &lt;button onClick={() =&gt; setRename(!rename)}&gt;Переименовать&lt;/button&gt;
    &lt;/&gt;
  )
}

function Counter({title}) {
  const [count, setCount] = useState(0);
  return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{title}: {count}&lt;/button&gt;
}</code></pre>
<p>Хотя в них одинаковая разметка и конечный HTML будет такой же как и в
предыдущих примерах, но здесь состояние будет сбрасываться, потому что
эти блоки самостоятельные и никак не связаны. Реакт будет отдельно
проверять, отрисовывать каждый блок или нет, соответственно и состояния
у них разные.</p>
<h2 id="вещь-3">Вещь #3</h2>
<blockquote>
<p>Состояние компонента определяется исключительно позицией в дереве
реакта (а не в конечном HTML-дереве).</p>
</blockquote>
<p>Пример: несмотря на то, что условие написано несколько странно и
возвращается разная JSX-разметка, в конечном итоге компонент Counter
оказывается в этих разметках на одном и том же месте - на первой позиции
и в теге <code>&lt;div&gt;</code>. Поэтому между перерисовками реакт
сохраняет его состояние.</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function StatePreserveDemo() {
  const [rename, setRename] = useState(true);
  if (rename) {
    return (
      &lt;&gt;
        &lt;div&gt;&lt;Counter title=&#39;Щелкунчик&#39; /&gt;&lt;/div&gt;
        &lt;button onClick={() =&gt; setRename(!rename)}&gt;Переименовать&lt;/button&gt;
      &lt;/&gt;
    )
  }
  return (
    &lt;&gt;
      &lt;div&gt;&lt;Counter title=&#39;Counter&#39; /&gt;&lt;/div&gt;
      &lt;div&gt;Наличие дополнительного элемента не сбросит состояние Counter&lt;/div&gt;
      &lt;button onClick={() =&gt; setRename(!rename)}&gt;Переименовать&lt;/button&gt;
    &lt;/&gt;
  )
}

function Counter({title}) {
  const [count, setCount] = useState(0);
  return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{title}: {count}&lt;/button&gt;
}</code></pre>
<h2 id="ключ-компонента-и-состояние">Ключ компонента и состояние</h2>
<p>Когда у компонента задан ключ, то это явным образом отличает его от
других компонентов, независимо от позиции. Вот пример, где компоненты
оказываются в одном и том же месте дерева, но реакт расценивает их как
разные, потому что мы явно задали им разные ключи:</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function StatePreserveDemo() {
  const [rename, setRename] = useState(true);
  return (
    &lt;&gt;
      {
        rename ? (
          &lt;div&gt;&lt;Counter key=&quot;clicker&quot; title=&#39;Щелкунчик&#39; /&gt;&lt;/div&gt;  {/* Выставим явно ключи */}
        ) : (
          &lt;div&gt;&lt;Counter key=&quot;counter&quot; title=&#39;Counter&#39; /&gt;&lt;/div&gt;  {/* Выставим явно ключи */}
        )
      }
      &lt;button onClick={() =&gt; setRename(!rename)}&gt;Переименовать&lt;/button&gt;
    &lt;/&gt;
  )
}

function Counter({title}) {
  const [count, setCount] = useState(0);
  return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{title}: {count}&lt;/button&gt;
}</code></pre>
<p>Соответственно, при переименовании состояние сбрасывается.</p>
<h2 id="косяк-компонентов-описанных-вложенной-функцией">Косяк
компонентов, описанных вложенной функцией</h2>
<p>Когда компонент описан через вложенную функцию, то при перерисовке
родительского компонента StatePreserveDemo получается, что функция
Counter каждый раз создается заново и реакт расценивает компонент
Counter как другой, поэтому если нащелкать счетчик, а потом нажать
кнопку “Флаг”, то счетчик сбросится:</p>
<pre class="react"><code>import {useState} from &#39;react&#39;;

export default function StatePreserveDemo() {
  const [flag, setFlag] = useState(true);

  function Counter({title}) {
    const [count, setCount] = useState(0);
    return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{title}: {count}&lt;/button&gt;
  }
  
  return (
    &lt;&gt;
      &lt;Counter title=&#39;Счетчик&#39; /&gt;
      &lt;button onClick={() =&gt; setFlag(!flag)}&gt;Флаг&lt;/button&gt;
    &lt;/&gt;
  );
}</code></pre>
<p>Если же объявить функцию Counter на верхнем уровне, то такой проблемы
не будет. P.S. Возникает вопрос, почему тогда счетчик в принципе
работает и не сбрасывается от щелчков по самому себе? Я думаю это
потому, что перерисовывается только он, а не родительский компонент.
Когда же мы щелкаем Флаг, то перерисовывается родительский компонент
целиком и вот тут вложенная функция дает косяк.</p>
<h2 id="итого">Итого</h2>
<p>Правило сохранения состояния:</p>
<ul>
<li>Если хотите, чтобы состояние компонента сохранялось между
перерисовками, то не меняйте его положение в итоговом UI-дереве
реакта.</li>
<li>Никогда не используйте для объявления компонентов вложенные функции
- всегда объявляйте их на верхнем уровне.</li>
</ul>
</body>
</html>
