<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>05 - Механика изменения состояния</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>
  <style type="text/css">body {background-color: green;}</style>
</head>
<body>
<h1 id="что-происходит-при-вызове-функции-изменения-состояния">Что
происходит при вызове функции изменения состояния</h1>
<p>Мы можем изменить состояние, вызвав функцию изменения, которую нам
возвращает хук useState. Пусть это функция setName. Передаем новое
значение состояния и оно заменяет старое.</p>
<p>Изменение состояния происходит асинхронно. Т.е. вызов setName не
приводит к немедленному изменению состояния.</p>
<p>Процесс изменения состояния состоит из нескольких шагов:</p>
<ul>
<li>Вызов setName формирует запрос на изменение состояния.</li>
<li>Этот запрос попадает в очередь запросов обновления.</li>
<li>Вызов setName также помечает компонент как “грязный”.</li>
<li>Грязный компонент передается в scheduler с указанием
приоритета.</li>
<li>scheduler планирует повторный рендер на основе приоритетов.</li>
</ul>
<p>Немного деталей:</p>
<ul>
<li>Запрос на изменение состояния - это объект, в котором находится либо
новое значение для состояния, либо функция для его изменения.</li>
<li>Очередь запросов обновления у каждого состояния своя. Она хранится в
объекте состояния в поле <code>updateQueue</code>. Где хранится сам
объект состояния - написано в соответствующем конспекте.</li>
<li>Приоритет запроса определяется исходя из того, где была вызвана
setName. Если, например, внутри клика по кнопке или изменения значения
поля, тогда у нее высокий приоритет. Если, например, внутри setTimeout,
тогда приоритет низкий. Это связано с тем, что реакт классифицирует
некоторые события как “пользовательские” (клик, изменение значения) и
считает их высокоприоритетными, а другие события - низкоприоритетными.
Соответственно, если запрос обновления произошел в пользовательском
событии, то и приоритет у этого запроса будет высокий.</li>
<li>scheduler - это механизм реакта, который ставит задачи на
выполнение, ориентируясь на их приоритеты. Приоритет setName не влияет
на сам setName, он определяет, с каким приоритетом компонент отправится
в scheduler. Если приоритет высокий, значит рендер этого компонента
случится вперед рендера компонента, у которого низкий приоритет. Если в
scheduler попадают несколько компонентов с высоким приоритетом, то
рендерится они будут в порядке очередности поступления - кто первее
поступил в scheduler, тот первее отрендерится.</li>
</ul>
<p>??? И тут вопрос - чтобы сравнивать новое дерево и старое, нужно это
новое сначала построить. Как это делается? Допустим, идет обход с корня.
Если какой-то компонент чистый, тогда он берется как есть, а если
грязный, тогда возможно повторно рендерится и так получается новое
дерево. Потом их можно сравнить например, вычислить изменения и
применить.</p>
<h1 id="пакетная-обработка-обновлений">Пакетная обработка
обновлений</h1>
<p>Если вызвать несколько функций изменения состояний, например,
setName, setAge, setSalary и т.д. в одном синхронном блоке (например,
при клике), тогда реакт сможет объединить их в пакет и выполнить за один
рендер.</p>
</body>
</html>
