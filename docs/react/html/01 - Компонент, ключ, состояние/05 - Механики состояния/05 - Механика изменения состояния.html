<!DOCTYPE html>
<html>
<head>
    <title></title>
    <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css'>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js'></script>
    <script>hljs.highlightAll();</script>
    <style>* {
  box-sizing: border-box;
}


html {
  scroll-behavior: smooth;

  text-align: justify;       /* Выравнивание по ширине */
  text-align-last: left;     /* Последняя строка - по левому краю */
  hyphens: auto;             /* Перенос слов (опционально) */
}


body {
  margin: 0;
  padding: 0;
  background-color: #1E1E1E;
}


h1 {
  font-size: 2.5rem;
}


.content {
  max-width: 800px;
  padding: 20px;
  margin: 0 auto;
  background-color: #FFC6A3;
}</style>
</head>
<body>
  <section class="content">
    <h1 id="что-происходит-при-вызове-функции-изменения-состояния">Что
    происходит при вызове функции изменения состояния</h1>
    <p>Мы можем изменить состояние, вызвав функцию изменения, которую
    нам возвращает хук useState. Пусть это функция setName. Передаем
    новое значение состояния и оно заменяет старое.</p>
    <p>Изменение состояния происходит асинхронно. Т.е. вызов setName не
    приводит к немедленному изменению состояния.</p>
    <p>Процесс изменения состояния состоит из нескольких шагов:</p>
    <ul>
    <li>Вызов setName формирует запрос на изменение состояния.</li>
    <li>Этот запрос попадает в очередь запросов обновления.</li>
    <li>Вызов setName также помечает компонент как “грязный”.</li>
    <li>Грязный компонент передается в scheduler с указанием
    приоритета.</li>
    <li>scheduler планирует повторный рендер на основе приоритетов.</li>
    </ul>
    <p>Немного деталей:</p>
    <ul>
    <li>Запрос на изменение состояния - это объект, в котором находится
    либо новое значение для состояния, либо функция для его
    изменения.</li>
    <li>Очередь запросов обновления у каждого состояния своя. Она
    хранится в объекте состояния в поле <code>updateQueue</code>. Где
    хранится сам объект состояния - написано в соответствующем
    конспекте.</li>
    <li>Приоритет запроса определяется исходя из того, где была вызвана
    setName. Если, например, внутри клика по кнопке или изменения
    значения поля, тогда у нее высокий приоритет. Если, например, внутри
    setTimeout, тогда приоритет низкий. Это связано с тем, что реакт
    классифицирует некоторые события как “пользовательские” (клик,
    изменение значения) и считает их высокоприоритетными, а другие
    события - низкоприоритетными. Соответственно, если запрос обновления
    произошел в пользовательском событии, то и приоритет у этого запроса
    будет высокий.</li>
    <li>scheduler - это механизм реакта, который ставит задачи на
    выполнение, ориентируясь на их приоритеты. Приоритет setName не
    влияет на сам setName, он определяет, с каким приоритетом компонент
    отправится в scheduler. Если приоритет высокий, значит рендер этого
    компонента случится вперед рендера компонента, у которого низкий
    приоритет. Если в scheduler попадают несколько компонентов с высоким
    приоритетом, то рендерится они будут в порядке очередности
    поступления - кто первее поступил в scheduler, тот первее
    отрендерится.</li>
    </ul>
    <p>??? И тут вопрос - чтобы сравнивать новое дерево и старое, нужно
    это новое сначала построить. Как это делается? Допустим, идет обход
    с корня. Если какой-то компонент чистый, тогда он берется как есть,
    а если грязный, тогда возможно повторно рендерится и так получается
    новое дерево. Потом их можно сравнить например, вычислить изменения
    и применить.</p>
    <h1 id="пакетная-обработка-обновлений">Пакетная обработка
    обновлений</h1>
    <p>Если вызвать несколько функций изменения состояний, например,
    setName, setAge, setSalary и т.д. в одном синхронном блоке
    (например, при клике), тогда реакт сможет объединить их в пакет и
    выполнить за один рендер.</p>
  </section>
</body>
</html>
