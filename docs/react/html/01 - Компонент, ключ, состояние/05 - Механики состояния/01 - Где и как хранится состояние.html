<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>01 - Где и как хранится состояние</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>
  <style type="text/css">body {background-color: green;}</style>
</head>
<body>
<h1 id="где-и-как-хранится-состояние">Где и как хранится состояние</h1>
<p>Каждый компонент, который мы пишем, в итоге превращается в fiber-узел
виртуального дерева интерфейса. Этот fiber-узел является обычным
объектом, в котором довольно много служебных полей, вроде ссылки на
родителя компонента, дочерние компоненты, соседей и т.д.</p>
<p>Среди всех этих служебных полей есть поле <code>memoizedState</code>.
В нем и хранится состояние.</p>
<p>У компонента может быть несколько независимых состояний, поскольку мы
можем использовать хук useState много раз. Состояния хранятся в виде
односвязного списка. Каждый элемент списка хранит как минимум три
значения:</p>
<ul>
<li>Сохраненное значение.</li>
<li>Функцию для изменения значения.</li>
<li>Ссылку на следующее значение.</li>
</ul>
<p>Это не единственные вещи, которые хранит объект состояния. Например,
у него есть еще одно поле - под запросы обновления состояния, в котором
(тоже в виде списка) хранятся запросы на обновление этого состояния. Это
я к тому, что не надо думать, что в объекте состояния только три этих
поля. Их там может быть гораздо больше, просто я упоминаю в конспекте
только те, которые относятся к текущей теме, чтобы не зашумлять
текст.</p>
<h1 id="почему-порядок-важен">Почему порядок важен</h1>
<p>При первом рендере компонента каждый вызов useState добавляет в
список очередное значение.</p>
<p>А при повторном рендере каждый вызов useState двигается по списку,
возвращает очередное значение и перемещает указатель на следующее. Таким
образом, последовательность вызовов useState важна, потому что значения
состояния извлекаются одно за другим и это единственная логика связи
значения с состоянием. Поэтому нельзя использовать хук useState в
каких-то условиях, циклах и т.д., ведь если один из вызовов пропустить,
тогда порядок извлечения нарушится и мы получим, например, в переменную
“вес” значение состояния “возраст”.</p>
</body>
</html>
