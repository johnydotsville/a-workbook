# Состояние компонента

## Функциональный компонент

### Хук useState

```react
import {useState} from 'react';
```

Состояние компонента - это некоторые данные, которые компонент использует. Например, состоянием компонента  "Анкета" может быть имя человека, профессия, дата рождения.

Работа с состоянием компонента начинается с вызова функции-хука `useState(начальное_состояние)`. Мы передаем в нее значение \ объект, который хотим использовать в качестве начального состояния, а она нам возвращает переменную, содержащую это состояние, плюс функцию для его изменения.

```react
const [состояние, функцияДляИзмененияСостояния] = useState(5);
const [login, setLogin] = useState('neofit');
```

Теперь, чтобы изменить состояние компонента, мы вызываем полученную от хука функцию, передавая в нее новое значение состояния. Вручную переменную состояния мы не изменяем, потому что в этом нет смысла, ибо реакт эти изменения не увидит, а используем ее для чтения состояния и формирования нового состояния на основе текущего. Т.о., состояние мы всегда воспринимаем как иммутабельное значение, которое можно **за**менить, но не **из**менить. Имя для функции изменения состояния может быть произвольным, но лучше при именовании следовать соглашению `переменнаяСостояния`, `setПеременнаяСостояния`.

У компонента может быть много состояний, т.е. мы можем применять хук useState сколько угодно раз. Состояние не стоит воспринимать как монолитный объект, содержащий все-все-все данные, касающиеся компонента. Наоборот, данные компонента могут быть разбиты на небольшие кусочки, несколько "состояний", каждое из которых может меняться независимо.

```react
import {useState} from 'react';

const Counter = () => {
  const [count, setCount] = useState(5);  // <-- Создали состояние и получили ф-ию для его измения
  const [calls, setCalls] = useState(0);  // <-- Другое состояние, под общее число кликов по счетчику

  function increment() {
    setCount(count + 1);  // <-- Сообщаем реакту об изменении состояния
    // Но саму переменную count мы не меняем
    setCalls(calls + 1);
  }

  function decrement() {
    setCount(count - 1);
    setCalls(calls + 1);
  }

  return (
    <div>
      <h1>{count}</h1>
      <h2>Общее число обращений к счетчику: {calls}</h2>
      <button onClick={increment}>Увеличить</button>
      <button onClick={decrement}>Уменьшить</button>
    </div>
  );
}

export default Counter;
```

## Классовый компонент

* В классовом компоненте состояние объявляется в конструкторе.
* Под состояние существует свойство `state`.
  * Для изменения состояния - метод `setState`.
* Все методы класса необходимо биндить, потому что теряется контекст. TODO: можно кстати почитать, почему так происходит.

```react
import React from 'react';

class Counter extends React.Component {
  
  constructor(props) {
    super(props);
    this.state = {  // <-- Объявление состояния
      count: 5
    };
    this.increment = this.increment.bind(this);  // <-- Надо биндить методы
    this.decrement = this.decrement.bind(this);  // <-- Надо биндить методы
  }

  increment() {
    this.setState({
      count: this.state.count + 1
    });
  }

  decrement() {
    this.setState({
      count: this.state.count - 1
    });
  }

  render() {
    return (
      <div>
        <h1>{this.state.count}</h1>
        <button onClick={this.increment}>Увеличить</button>
        <button onClick={this.decrement}>Уменьшить</button>
      </div>
    );
  }

}

export default Counter;
```

# Советы по оформлению состояния

Несколько советов по оформлению состояния:

* Группируйте связанные состояния. Если вы обнаружили, что обычно изменяете две и более переменные состояния вместе и они логически тесто связаны, то лучше их объединить в единый объект.
* Избегайте противоречий в состоянии. Если у вас несколько состояний, значения которых могут конфликтовать, то эти состояния нужно отрефакторить, чтобы такого конфликта в принципе не могло произойти. Например, комбинация `isSending = true` и `isSent = true` является некорректной с точки зрения логики программы, потому что сообщение не может одновременно отправлять и быть уже отправленным. Пример рефакторинга - ввести состояние `status` с возможными значениями sending и sent.
* Избегайте избыточности в состоянии. Если какие-то значения можно вычислить на основе имеющихся средств (например пропсы или другие состояния), то не нужно для этих значений заводить отдельное состояние. Пример избыточного состояния: `firstname`, `lastname`, `fullname`. Здесь fullname можно вычислить на основе firstname и lastname, поэтому держать его как отдельное состояние не следует.
* Избегайте дублирования в состоянии. Не стоит использовать одни и те же данные как части разных состояний, потому что их придется держать их в согласованном виде, а это повышает вероятность ошибок. Например: список элементов и состояние `selectedItem`. Если сохранить в selectedItem непосредственно ссылку на элемент, то это плохая идея. Из-за иммутабельности, в случае изменений в выделенном элементе, нам придется заменять элемент и в selectedItem. Проще и правильнее будет сохранить в selectedItem id выбранного элемента.
* Избегайте сильной вложенности в состоянии. Старайтесь делать состояние как можно более плоским, потому что так его будет проще обновлять.

