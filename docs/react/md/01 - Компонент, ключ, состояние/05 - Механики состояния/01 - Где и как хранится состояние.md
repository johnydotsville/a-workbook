# Где и как хранится состояние

Каждый компонент, который мы пишем, в итоге превращается в fiber-узел виртуального дерева интерфейса. Этот fiber-узел является обычным объектом, в котором довольно много служебных полей, вроде ссылки на родителя компонента, дочерние компоненты, соседей и т.д.

Среди всех этих служебных полей есть поле `memoizedState`. В нем и хранится состояние.

У компонента может быть несколько независимых состояний, поскольку мы можем использовать хук useState много раз. Состояния хранятся в виде односвязного списка. Каждый элемент списка хранит как минимум три значения:

* Сохраненное значение.
* Функцию для изменения значения.
* Ссылку на следующее значение.

Это не единственные вещи, которые хранит объект состояния. Например, у него есть еще одно поле - под запросы обновления состояния, в котором (тоже в виде списка) хранятся запросы на обновление этого состояния. Это я к тому, что не надо думать, что в объекте состояния только три этих поля. Их там может быть гораздо больше, просто я упоминаю в конспекте только те, которые относятся к текущей теме, чтобы не зашумлять текст.

# Почему порядок важен

При первом рендере компонента каждый вызов useState добавляет в список очередное значение.

А при повторном рендере каждый вызов useState двигается по списку, возвращает очередное значение и перемещает указатель на следующее. Таким образом, последовательность вызовов useState важна, потому что значения состояния извлекаются одно за другим и это единственная логика связи значения с состоянием. Поэтому нельзя использовать хук useState в каких-то условиях, циклах и т.д., ведь если один из вызовов пропустить, тогда порядок извлечения нарушится и мы получим, например, в переменную "вес" значение состояния "возраст".

